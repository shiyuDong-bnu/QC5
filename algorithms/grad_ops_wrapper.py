import numpy as np
from mindquantum import Simulator
from mindquantum.core.circuit.utils import add_prefix
from mindquantum.core.operators import QubitOperator,Hamiltonian

#from QC_master.hamiltonians.FerOp_QubitOp import get_qubit_opVdV
# def get_e0_and_varience(qubit_hamiltonian,hea_info,theta0):
#     """var = <phi_opt|(H-e0)^2|psi_opt>"""
#     # hea_info = [nqubits,nelec,nlayer,hea_type,ref]
#     ansatz_circuit = get_hea_ansatz(*hea_info)
#     pr = dict(zip(ansatz_circuit.params_name,theta0))
#     ansatz_circuit = ansatz_circuit.apply_value(pr=pr)
#     e0 = get_expect_value_v2(qubit_hamiltonian,ansatz_circuit)
#     opH = qubit_hamiltonian-e0
#     opHdH = get_qubit_opVdV(opH)
#     var = get_expect_value_v2(opHdH,ansatz_circuit)
#     return e0,var

def get_ovlp_pqc(ansatz_circuit, encoder_circuit):
    #  <psi0|psi1> 
    sim = Simulator('mqvector',ansatz_circuit.n_qubits)
    iden = Hamiltonian(QubitOperator(''))
    ovlp_pqc_op = sim.get_expectation_with_grad(iden,
                                                ansatz_circuit,
                                                encoder_circuit.as_encoder(),)
    return ovlp_pqc_op

def get_ovlp_value(ansatz_amps, encoder_amps, ansatz_circuit, encoder_circuit=None):
    if encoder_circuit is None:
        encoder_circuit = add_prefix(ansatz_circuit, 'e')
    ovlp_pqc_op = get_ovlp_pqc(ansatz_circuit, 
                               encoder_circuit)
    encoder_amps = encoder_amps.reshape(1,encoder_amps.shape[0])
    value = ovlp_pqc_op(encoder_amps,ansatz_amps)[0]
    value = np.real(value)[0, 0]
    return value

def get_expect_value(qubit_operator,ansatz_circuit,ansatz_amps):
    """return the value of obserable under the specified ansatz"""
    exp_pqc_op = get_expect_pqc(qubit_operator, ansatz_circuit)
    value,grad = exp_pqc_op(ansatz_amps)
    value = np.real(value)[0, 0]
    return value

def get_expect_value_v2(qubit_op,ansatz_circuit):
    """ this version the ansatz should bind value before input"""
    sim = Simulator('mqvector',ansatz_circuit.n_qubits)
    sim.apply_circuit(ansatz_circuit)
    ham = Hamiltonian(qubit_op)
    energy = sim.get_expectation(ham)
    return energy.real 

def get_expect_pqc(qubit_operator, ansatz_circuit):
    """return the parameterized quantum circuit generated by mindquantum"""   
    # <psi1|H|psi1>
    sim = Simulator('mqvector',ansatz_circuit.n_qubits)
    if ansatz_circuit.n_qubits<18:
        ham = Hamiltonian(qubit_operator).sparse(ansatz_circuit.n_qubits)
    else:
        ham = Hamiltonian(qubit_operator)
    #ham = Hamiltonian(qubit_operator).sparse(ansatz_circuit.n_qubits)
    ene_pqc_op = sim.get_expectation_with_grad(ham,ansatz_circuit)    
    return ene_pqc_op

def get_cross_pqc(qubit_operator,ansatz_circuit,encoder_circuit):

    # ansatz_circuit|x>, encoder_circuit <psi0|
    encoder_circuit = add_prefix(encoder_circuit, 'e') #rename encoder params
    encoder_circuit = encoder_circuit.no_grad()
    #  <psi0|qubit_op|psi1> 
    sim = Simulator('mqvector',ansatz_circuit.n_qubits)
    ham = Hamiltonian(qubit_operator).sparse(ansatz_circuit.n_qubits)
    cross_pqc_op = sim.get_expectation_with_grad(ham,
                                                 ansatz_circuit,
                                                 encoder_circuit.as_encoder(),)

    return cross_pqc_op